; BSOD64 (C) Kroc Camen, 2019-2023
; licenced under BSD 2-clause
;===============================================================================
; BSOD64 is a "blue screen of death" for C64 programs. why would you want that?
;
; ...
;
; DESIGN GOALS:
;-------------------------------------------------------------------------------
; * completely self-contained:
; - no external dependencies
; - does not need to be compiled into your own program
;   (include as a binary blob, or load-in from disk)
; - can be loaded from and operated within BASIC
; - resides in "unused" memory ($C000..$E000)
;
; * small:
; - maximum limit of 4 KB code
; - favours small code over speed / memory usage
; - uses only official KERNAL calls / addresses, so should work with
;   alternative ROMs such as Jiffy DOS, Dolphin DOS, C128 &c.
;
; THEORY OF OPERATION:
;-------------------------------------------------------------------------------
; an interrupt is a way for external signals to stop the processor and get it
; to run some other code to deal with the signal immediately, before resuming
; where it was before. a handful of parts in the C64 can generate interrupts
; (the CIAs, VIC-II, SID) but the 6502 also has an instruction, BRK, that can
; interrupt the currently running code. its purpose is for debugging, as it
; provides a way to stop the program at any point and jump to a completely
; different program (a debugger, e.g. BSOD64)
;
; the Commodore 64, in particular, has its RESTORE key wired to the CPU rather
; than the keyboard matrix. no matter what state the user's program is in, even
; if it's not checking the keyboard, the RESTORE key will raise a "Non-Maskable
; Interrupt" (NMI), a special type of interrupt separate to BRK. likewise, this
; provides us another way to halt [and debug] a running program
;
; unfortunately, the C64/6502 hardware does not allow us
; to just instantly jump to BSOD64 upon an NMI or BRK:
;
; *     there is no hardware BRK vector; an IRQ is fired instead with
;       the BRK-bit set, so some decoding overhead is already required
;       to separate regular interrupts from a BRK
;
; *     the KERNAL ROM does its own NMI/IRQ/BRK handling before we are able
;       to take over. disabling the KERNAL ROM is possible but then the system
;       crashes if we don't provide our own replacements, and regardless, both
;       environments must be handled as we can't assume which state the user's
;       program will be in when a BRK occurs
;
; *     the KERNAL ROM's IRQ handler pushes the registers to the stack before
;       calling the user-handler, but the KERNAL's NMI handler does not! some
;       normalisation is required to handle both behaviours equally
;
; *     a normal JSR or interrupt subtracts one from the program counter before
;       pushing it to the stack, this is because the RTS instruction always
;       automatically adds 1 to the program counter (an internal detail).
;       the BRK instruction, however *adds* 1 to the program counter before 
;       pushing it to the stack! returning from a BRK interrupt therefore skips
;       over a byte unless this is accounted for!
;
; when BSOD64 is invoked, the areas of memory that BSOD64 needs to re-use are
; copied to the RAM under the I/O space. since this RAM is very difficult to
; use, it's the most likely "unused" RAM on the system and the last area
; a developer will want to utilise before any other
;
; base address where BSOD64 is assembled -- CANNOT be under a ROM shadow!
!ifndef BSOD64_CODE_ADDR        BSOD64_CODE_ADDR = $c000        ; sys 49152
; where BSOD64 backs up data, can be under I/O but not KERNAL
!ifndef BSOD64_DATA_ADDR        BSOD64_DATA_ADDR = $d000

; is the data under I/O?
!if BSOD64_DATA_ADDR >= $d000 & BSOD64_DATA_ADDR < $e000 {
        BSOD64_UNDER_IO = 1
}

!zone   bsod64 {
!source "system.acme"

;===============================================================================
!addr {
                        ; (base address of frozen data)
.frzn                   = BSOD64_DATA_ADDR
                        ; backup of zero-page ($0000-$00FF)
.frzn_zp                = BSOD64_DATA_ADDR
                        ; backup of stack ($0100-$1FF)
.frzn_stack             = BSOD64_DATA_ADDR + $100
                        ; backup of KERNAL work-RAM ($0200-$02FF)
.frzn_work              = BSOD64_DATA_ADDR + $200
                        ; backup of KERNAL/BASIC vectors ($0300-$03FF)
.frzn_vectors           = BSOD64_DATA_ADDR + $300
                        ; backup of text screen ($0400-$07FF)
.frzn_screen            = BSOD64_DATA_ADDR + $400
                        ; backup of colour RAM ($D800-$DBFF)
.frzn_color             = BSOD64_DATA_ADDR + $800
                        ; backup of VIC-II registers (46-bytes)
.frzn_vic               = BSOD64_DATA_ADDR + $c00
                        ; backup of NMI vector at $FFFA
.frzn_nmi               = BSOD64_DATA_ADDR + $c40
.frzn_nmi_lo            = BSOD64_DATA_ADDR + $c40
.frzn_nmi_hi            = BSOD64_DATA_ADDR + $c41
                        ; backup of IRQ vector at $FFFE
.frzn_irq               = BSOD64_DATA_ADDR + $c42
.frzn_irq_lo            = BSOD64_DATA_ADDR + $c42
.frzn_irq_hi            = BSOD64_DATA_ADDR + $c43

;-------------------------------------------------------------------------------
; address pointer used for printing memory values
; e.g. display the memory hexdump
.zp_addr                = $03
.zp_addr_lo             = $03
.zp_addr_hi             = $04

;-------------------------------------------------------------------------------
; address for string indexing
; ("pointer to memory allocated for current string variable")
.zp_str                 = $35
.zp_str_lo              = $35
.zp_str_hi              = $36

;===============================================================================
; where a JMP instruction is overwritten,
; this is the placeholder address
.null_addr              = $8888
}
; where an instruction operand is overwritten,
; this is the placeholder value
.NULL_VALUE             = $88

; terminators used for the string-printing routines:
;
.STR_END                = $00   ; standard terminator
.STR_POS                = $f0   ; change cursor pos; row & col bytes follow
.STR_REPT               = $f1   ; repeat a character
.STR_HEXW               = $f2   ; print the 16-bit value that follows in hex
.STR_HEXB               = $f3   ; print the 8-bit value that follows in hex
.STR_FLAGS              = $f4   ; print a binary value as a set of flags


;===============================================================================
; 888888b.    .d8888b.   .d88888b.  8888888b.   .d8888b.      d8888
; 888  "88b  d88P  Y88b d88P" "Y88b 888  "Y88b d88P  Y88b    d8P888
; 888  .88P  Y88b.      888     888 888    888 888          d8P 888
; 8888888K.   "Y888b.   888     888 888    888 888d888b.   d8P  888
; 888  "Y88b     "Y88b. 888     888 888    888 888P "Y88b d88   888
; 888    888       "888 888     888 888    888 888    888 8888888888
; 888   d88P Y88b  d88P Y88b. .d88P 888  .d88P Y88b  d88P       888
; 8888888P"   "Y8888P"   "Y88888P"  8888888P"   "Y8888P"        888
;===============================================================================
* = BSOD64_CODE_ADDR


bsod_basic:                                     ; (`SYS 49152` / `jsr $c000`)
;===============================================================================
; install BSOD64's launch hooks:
;
; this will alter the system interrupts to launch BSOD64 whenever the RESTORE
; key is pressed, or the BRK instruction is encountered in running code
; 
; if you are using your own interrupt code then you will need to include a
; small piece of code at the beginning of your IRQ / NMI routine to invoke
; BSOD64
;
;-------------------------------------------------------------------------------
        jmp bsod_hook


bsod_jsr:                                       ; (`SYS 49155` / `jsr $c003`)
;===============================================================================
; invoke BSOD64 manually with a JSR;
; i.e. not using a NMI/IRQ/BRK handler
;
; THIS ASSUMES THE FOLLOWING STACK LAYOUT:
;
;       top  -> PC lo-byte              (pushed by JSR to here)
;               PC hi-byte              (pushed by JSR to here)
;
;-------------------------------------------------------------------------------
        ; push the processor status and registers to the stack
        ; to normalise the stack layout for BSOD64
        jsr .bsod_push

        ; fallthrough
        ; ...

bsod_irq:                                       ; (`SYS 49158` / `jsr $c006`)
;===============================================================================
; invoke BSOD64 from an interrupt (IRQ/NMI/BRK) environment:
;
; THIS ASSUMES THE FOLLOWING STACK LAYOUT:
;
;       top  -> return-address, lo-byte (pushed by the JSR here)
;               return-address, hi-byte (pushed by the JSR here)
;               Y register              (pushed by the IRQ/NMI handler)
;               X register              (pushed by the IRQ/NMI handler)
;               A register              (pushed by the IRQ/NMI handler)
;               processor status        (pushed by hardware interrupt)
;               PC lo-byte              (pushed by hardware interrupt)
;               PC hi-byte              (pushed by hardware interrupt)
;
;-------------------------------------------------------------------------------
        ; disable interrupts first, we must stop any more host code from
        ; running! note that because the hardware interrupt pushed the
        ; processor state to the stack we can recover the original
        ; interrupt state from there 
        sei

        ; fallthrough
        ; ...

.bsod_freeze:
;===============================================================================
; freeze the state of the machine:
; (NEVER CALL THIS DIRECTLY -- *ALWAYS* use `bsod_jsr` or `bsod_irq` above)
;
; because invoking BSOD64 requires some stack use (see above), we will
; consume the stack bytes used by BSOD64 so that the frozen stack pointer
; represents the stack level at the point of the NMI/BRK/JSR to BSOD64
;
;-------------------------------------------------------------------------------
        ; we do not know if decimal mode was in use, turn it off before
        ; we do any math (this is a hardware-flaw with the NMOS 6502)
        cld

        pla                     ; consume the JSR address
        pla                     ;  to this routine (not used)

        ; backup the registers that were pushed on to the stack by the
        ; IRQ/NMI routine (or BSOD64 itself in the case of `bsod_jsr`)
        pla                     ; 1st register on stack
        sta .frzn_y             ; keep an original copy of Y
        pla                     ; 2nd register on stack
        sta .frzn_x             ; keep an original copy of X
        pla                     ; 3rd register on stack
        sta .frzn_a             ; keep an original copy of A

        ; below the registers should be the processor status at the time of
        ; interrupt. we will need this to determine if BSOD64 was invoked by
        ; a BRK instruction. if JSR is used, the flags will have been pushed
        ; manually by a PHP instruction in `.bsod_push`
        ;
        pla                     ; read processor flags from interrupt
        sta .frzn_f             ; keep an original copy

        ; make a note if BSOD64 was invoked by a BRK instruction:
        ; this flag is only valid with an interrupt; if BSOD64 is invoked
        ; by JSR, the BRK flag is *always* set by the PHP instruction
        ;
        and # %00010000         ; isolate the BRK bit
        beq +                   ; use $00 for non-BRK
        lda # $80               ; use $80 for BRK (bit7=1)
+       sta .bsod_is_brk        ; (not valid if .bsod_is_jsr is set!)

        ; and lastly extract the program-counter:
        ;
        pla                     ; program counter lo-byte
        tax                     ; keep temporarily for adjusting
        pla                     ; program counter hi-byte
        tay                     ; keep temporarily for adjusting

        ; fix program counter:
        ;-----------------------------------------------------------------------
        ; the address pushed on the stack with JSR is one byte less
        ; than the next instruction in the code due to the 6502 processor
        ; auto-incrementing the program counter with an RTS instruction;
        ; if BSOD64 is invoked by JSR then we need to correct for this!
        ;
        bit .bsod_is_jsr        ; check for the JSR flag
        bmi @pcjsr              ; if yes, add one to PC

        ; check for BRK / BRK code:
        ;
        ; the BRK interrupt incremented the PC by 2, skipping a byte --
        ; we want to read that byte back as the programmer's BRK code
        ;
        bit .bsod_is_brk        ; was BRK interrupt?
        bpl @pc                 ; if no, skip

        ; decrement the PC by 1 to get at the BRK parameter:
        ;
        txa                     ; retrieve PC, lo-byte
        bne +                   ; if zero, it'll cause an underflow
        dey                     ; -> decrement the PC hi-byte
+       dex                     ; subtract 1 from the PC, lo-byte

        ; read the BRK code from PC-1:
        stx @pcbrk+1
        sty @pcbrk+2
@pcbrk  lda .null_addr
        sta .frzn_brk

        ; fall through to the PC+1 code
        ; to put the PC back where it was!
        ; ...

        ; correct PC for JSR:
@pcjsr: inx                     ; add 1 to PC, lo-byte
        bne +                   ; if it overflowed
        iny                     ; -> increment PC, hi-byte

+       ; store the adjusted PC for printing:
@pc:    stx .frzn_pc_lo
        sty .frzn_pc_hi

        ; all bytes pulled from stack,
        tsx                     ; get the stack pointer
        stx .frzn_sp            ; keep an original copy

        ; freeze low-memory:
        ;-----------------------------------------------------------------------
        ; the area we will backup to is under I/O, so before we can write there
        ; we need to change the memory layout. first we backup the processor
        ; port, and then change memory layout to turn off I/O
        ;
        ; the "data direction register" determines what bits of the processor
        ; port can be written to. this is important to make use of because the
        ; Datasette control lines are part of the processor port and you don't
        ; want to play around with the tape when changing memory layout
        ;
        ; we actually want to stop the tape motor when freezing BSOD64,
        ; so we set the data-direction register to allow us to turn off bit 5
        ;
        lda .zp+0               ; current CPU data-direction register
        sta .frzn_cpu_ddir      ; save to frozen state
        lda # %00101111         ; reset the data-direction register,
        sta .zp+0               ;  to its default value
        lda .zp+1               ; current CPU port value
        sta .frzn_cpu_port      ; save to frozen state

        lda # .MEM_ALL_RAM      ; disable I/O & ROM!
        sta .zp+1               ; all RAM is visible

        ; backup the low eight pages of memory:
        ;
        ldx # 0
        ; backup the zero-page: note that addresses 0/1 have been modified
        ; from the originals above, so we will want to insert the original
        ; values into the frozen zero-page after the backup
-       lda .zp, x
        sta .frzn_zp, x
        ; backup the original stack: since BSOD64 will be using the stack
        ; too, we will want to take a copy of the stack at freeze-time
        lda .stack, x
        sta .frzn_stack, x
        ; backup the KERNAL/BASIC work RAM at $0200-$02FF:
        lda .work, x
        sta .frzn_work, x
        ; backup the KERNAL/BASIC vectors at $0300-$03FF:
        lda .vector, x
        sta .frzn_vectors, x
        ; backup the original text screen at $0400-$07FF:
        lda .screen      + $000, x
        sta .frzn_screen + $000, x
        lda .screen      + $100, x
        sta .frzn_screen + $100, x
        lda .screen      + $200, x
        sta .frzn_screen + $200, x
        lda .screen      + $300, x
        sta .frzn_screen + $300, x
        ; rinse and repeat
        dex
        bne -

        lda .frzn_cpu_ddir      ; take the original data-direction value
        sta .frzn_zp+0          ;  and put into the frozen zero-page
        lda .frzn_cpu_port      ;  and do the same with the CPU port value
        sta .frzn_zp+1

        ; with KERNAL off, we can backup the hardware vectors underneath:
        ; the non-maskable interrupt, wired to the RESTORE key & CIA2
        lda .cpu_nmi_lo
        sta .frzn_nmi_lo
        lda .cpu_nmi_hi
        sta .frzn_nmi_hi
        ; the interrupt request vector, wired to CIA1 and VIC-II
        lda .cpu_irq_lo
        sta .frzn_irq_lo
        lda .cpu_irq_hi
        sta .frzn_irq_hi

        ; freeze VIC-II:
        ;-----------------------------------------------------------------------
        ; backup CIA #2 port A which holds the VIC bank
        ;
        inc .zp+1               ; enable the I/O shield to access CIA #2
        lda .cia2+.CIA_PORTA    ; read CIA #2 port A
        sta .frzn_cia2          ; store locally, I/O doesn't need to be off

        ; if the frozen data is *not* stored under I/O then we can
        ; leave I/O on for the whole copy rather than each byte
        ;
!ifdef  BSOD64_UNDER_IO         dec .zp+1       ; disable I/O

        ; backup the VIC-II state before we start changing the screen:
        ;
        ldx # .VIC_COUNT        ; number of VIC-II registers

-       ; if frozen state is under I/O,
        ; enable I/O to read the VIC-II register
!ifdef  BSOD64_UNDER_IO         inc .zp+1
        lda .vic, x             ; read the VIC-II register
!ifdef  BSOD64_UNDER_IO         dec .zp+1
        sta .frzn_vic, x        ; write to the frozen state
        dex
        bpl -

        ; backup colour RAM:
        ;-----------------------------------------------------------------------
        ; this is done in four stripes to avoid using a nested loop. note that
        ; because BSOD64 stores the frozen machine state under I/O, we have to
        ; turn I/O on & off for each read + write. whilst this is not ideal,
        ; it is the most-likely-to-be-unused memory available to us
        ;
        ldx # 0
-       
!ifdef  BSOD64_UNDER_IO         inc .zp+1
        lda .vic_color  + $000, x
!ifdef  BSOD64_UNDER_IO         dec .zp+1
        sta .frzn_color + $000, x
!ifdef  BSOD64_UNDER_IO         inc .zp+1
        lda .vic_color  + $100, x
!ifdef  BSOD64_UNDER_IO         dec .zp+1
        sta .frzn_color + $100, x
!ifdef  BSOD64_UNDER_IO         inc .zp+1
        lda .vic_color  + $200, x
!ifdef  BSOD64_UNDER_IO         dec .zp+1
        sta .frzn_color + $200, x
!ifdef  BSOD64_UNDER_IO         inc .zp+1
        lda .vic_color  + $300, x
!ifdef  BSOD64_UNDER_IO         dec .zp+1
        sta .frzn_color + $300, x
        dex
        bne -

        ; reset machine state:
        ;-----------------------------------------------------------------------
        ; backup the byte at $A000 in RAM as the RAM test clobbers it!
        ; this interesting quirk of the boot procedure brought to light
        ; by Greg Na√ßu: <https://c64os.com/post/loadrunfromasm1>
        ;
        ; BASIC ROM is currently off so we can access the RAM underneath.
        ; when the RAM test runs, it will clobber byte $A000 once it hits
        ; BASIC ROM, we need to backup and then restore this byte later
        ;
        lda $a000
        sta .ramtas_fix

        ; enable KERNAL ROM:
        ;
        lda # .MEM_KERNAL_IO    ; enable BASIC,
        sta .zp+1               ;  KERNAL & I/O

        lda # %00000000         ; turn screen off
        sta .vic+.VIC_SCREEN_VERT

        ; NOTE: we *must* create correct zero-page values for the KERNAL
        ;       to be enabled, in case the user's program fills zero-page
        ;       without concern for KERNAL!
        ;
        ; this KERNAL routine erases the zero page, pages 2 & 3, and runs
        ; a memory test before configuring BASIC limits. it sets the page
        ; number for screen memory to $04 just before it exits, but does
        ; not change the actual VIC bank. the stack pointer is also reset
        ; by this routine so we don't need to do it ourself
        ;
        jsr .kernal_ramtas      ; (does not enable interrupts)

        ; restore the default vector table at $0314-$0333:
        ; this will ensure that KERNAL-handled interrupts will point back
        ; to the KERNAL and not to code from the frozen program
        ;
        jsr .kernal_restor      ; (does not enable interrupts)

        ; put handlers in place for interrupts when BSOD64 is running:
        ;
        ; now that BSOD64 is invoked we don't want BSOD-ception! due to the
        ; vectors being reset (above), the default KERNAL handlers will be
        ; in place; we want to override RESTORE (nmi) and BRK handlers,
        ; as well as provide safety stubs for when KERNAL ROM is off
        ;
        ; install the NMI handler:
        ; (KERNAL vectored NMI handler -- stop RESTORE key)
        lda #< .bsod_nmi_kernalon
        sta .vectors+.VECTOR_NMI+.lo
        lda #> .bsod_nmi_kernalon
        sta .vectors+.VECTOR_NMI+.hi
        ; (CPU vectored NMI handler -- ignore RESTORE during KERNAL off)
        lda #< .bsod_nmi_nokernal
        sta .cpu_nmi_lo         ; (note: write-through-ROM)
        lda #> .bsod_nmi_nokernal
        sta .cpu_nmi_hi         ; (note: write-through-ROM)

        ; install the IRQ handler:
        ; (KERNAL vectored BRK handler)
        lda #< .bsod_rti
        sta .vectors + .VECTOR_BRK+.lo
        lda #> .bsod_rti
        sta .vectors + .VECTOR_BRK+.hi
        ; (CPU vectored IRQ handler - IRQ during KERNAL off)
        lda #< .bsod_irq_nokernal
        sta .cpu_irq_lo         ; (note: write-through-ROM)
        lda #> .bsod_irq_nokernal
        sta .cpu_irq_hi         ; (note: write-through-ROM)

        ; restore the RAMTAS $A000 byte:
        ;
        dec .zp+1               ; turn off BASIC ROM (opening $A000 to RAM)
        lda .ramtas_fix         ; read the original byte
        sta $a000               ;  and restore it
        inc .zp+1               ; turn BASIC ROM back on

        ; fallthrough
        ; ...

.bsod_BSOD:
;===============================================================================
        ; re-initialise the CIAs, enable I/O and BASIC+KERNAL ROMs,
        ; also silences the SID chip
        ;
        jsr .kernal_ioinit      ; (does not enable interrupts)

        ; re-initialise VIC-II
        jsr .kernal_scinit      ; (does not enable interrupts)

        ; a BSOD must be blue...
        lda # .VIC_BLUE
        sta .vic+.VIC_SCREEN_BORDER
        sta .vic+.VIC_SCREEN_BKGRND

        ; this should be handled by SCINIT?
        ;;lda # %00011011         ; 25 rows, screen on
        ;;sta .vic+.VIC_SCREEN_VERT

        ; enable interrupts and hope
        ; the machine doesn't crash
        cli

        ; decode the frozen ROM/RAM bank state:
        ;-----------------------------------------------------------------------
        ; VIC bank is done first as other banking goes over this
        ;
        ldx # 12                ; VIC bank 3 starts on the 12th page
        lda .frzn_cia2          ; frozen state of CIA#2 port A
        and # %00000011         ; we only care about the bottom two bits
        beq +                   ; =%00? VIC bank 3 ($C000-$FFFF)
        ldx # 8                 ; VIC bank 2 starts on the 8th page
        cmp # %00000001         ; =%01?
        beq +                   ; VIC bank 2 ($8000-$BFFF)
        ldx # 4                 ; VIC bank 1 starts on the 4th page
        cmp # %00000010         ; =%11?
        beq +                   ; VIC bank 1 ($4000-$7FFF)

        ; otherwise, VIC bank 0 ($0000-$3FFF)
        ldx # 0                 ; VIC bank 0 starts on the 0th page
+       lda # 'V'               ; use consumate "v"s for VIC bank
        sta .str_banks_vic+0, x
        sta .str_banks_vic+1, x
        sta .str_banks_vic+2, x
        sta .str_banks_vic+3, x

        ; ROM banks:
        lda .frzn_cpu_port
        and # %00000011         ; we only care about the bottom bits
        beq +                   ; %00 = all RAM, nothing else

        ; any non-zero value implies
        ; that the I/O shield is on
        ;
        ldy # 'I'               ; use an "i" in bank $D to indicate I/O on
        sty .str_banks_i

        sec
        sbc # 1
        beq +

        ldy # 'K'               ; use a "k" in banks $E & $F for KERNAL on
        sty .str_banks_k+0
        sty .str_banks_k+1

        sbc # 1
        beq +

        ldy # 'B'               ; use a "b" in banks $A & $B for BASIC on
        sty .str_banks_b+0
        sty .str_banks_b+1

+       lda #< .str_top
        ldx #> .str_top
        jsr .bsod_print

        ; print frozen stack:
        ;-----------------------------------------------------------------------
        ldy .frzn_sp
        iny
        beq +

        lda #< .frzn_stack
        sta .zp_addr_lo
        lda #> .frzn_stack
        sta .zp_addr_hi
        jsr .bsod_pop16

        ; print bottom status bar:
        ;-----------------------------------------------------------------------
+       lda #< .str_status
        ldx #> .str_status
        jsr .bsod_print

        ; display the method BSOD64 was invoked with; JSR/NMI or BRK:
        ;
        bit .bsod_is_jsr        ; invoked with JSR? 
        bpl +
        lda #< .str_jsr         ; print "JSR"
        ldx #> .str_jsr         ; ...
        bne ++
+       bit .bsod_is_brk        ; invoked with BRK?
        bpl +
        lda #< .str_brk         ; print "BRK:$xx"
        ldx #> .str_brk         ; where xx is the BRK parameter
        bne ++
+       lda #< .str_nmi         ; print "NMI"
        ldx #> .str_nmi         ; ...

        ; the string address having been selected, print it
++      jsr .bsod_print

        ; we can't print the bottom-rightmost character on the screen
        ; or it'll scroll, so we POKE it in manually
        ;
        lda # ' '+$80           ; (screen code for reverse space)
        sta .screen+(40*24)+39

        ; fallthrough
        ; ...

.bsod_BSOD_refresh:
        ;=======================================================================
        lda #< .str_mem
        ldx #> .str_mem
        jsr .bsod_print

        ; print frozen memory page:
        ;-----------------------------------------------------------------------
        ; select the page of memory to view (default: $00)
        lda .frzn_page
        ; instead of showing the actual page $00-$07,
        ; show the contents of the frozen version
        cmp # 8
        bcs +
        adc # >BSOD64_DATA_ADDR ; re-base address into the frozen data area
+       sta .zp_addr_hi         ; write into code that reads from address
        ldy # $00               ; Y will be byte counter
        sty .zp_addr_lo         ;  and starting address lo-byte

--      lda # "$"
        jsr .kernal_chrout
        tya
        jsr .bsod_print_hex8
        lda # ":"
        jsr .kernal_chrout

        jsr .bsod_pop16

        lda # .PET_RETURN
        jsr .kernal_chrout

        tya
        bne --

        ; keyloop:
        ;
.wait_for_key:
        ;=======================================================================
        ; read from the keyboard buffer:
        ;
        ; note that because the standard KERNAL interrupts are running,
        ; `.kernal_scnkey` is being called to populate the buffer for us
        ;
        jsr .kernal_getin       ; fetch a keypress -- returns in PETSCII!
        beq .wait_for_key       ; if 0, no keypress, keep waiting
        
        cmp # .PET_CRSR_UP      ; cursor-up:
        beq @page_prev          ; - show previous memory page
        cmp # .PET_CRSR_LT      ; cursor-left:
        beq @page_prev          ; - same
        cmp # .PET_CRSR_DN      ; cursor-down:
        beq @page_next          ; - show next memory page
        cmp # .PET_CRSR_RT      ; cursor-right:
        beq @page_next          ; - same
        cmp # .PET_0            ; keys 0...
        bcc +                   ;  through
        cmp # .PET_9+1          ; 9:
        bcc @page_jump_09       ; - switch to pages $0x to $9x
+       cmp # .PET_A_LO         ; keys A...
        bcc +                   ;  through
        cmp # .PET_F_LO+1       ; F:
        bcc @page_jump_AF       ; - switch to pages $Ax to $Fx
+       cmp # .PET_F1           ; F1:
        bne +                   ; - show frozen screen
        jmp @f1

+       jmp .wait_for_key

        ; change memory page:
        ;=======================================================================
@page_jump_09:
        sbc # (.PET_0)-1        ; adjust PETSCII code to 0-9
        !byte $2c               ; (skip next two bytes)
@page_jump_AF:
        sbc # (.PET_A_LO-10)-1  ; adjust PETSCII code to 10-15
        asl                     ; 
        asl                     ; shift value $0-$F
        asl                     ;  to upper nybble
        asl                     ;
        sta @hi+1               ; combine with lo-nybble later

        lda .frzn_page          ; current selected memory page
        and # %00001111         ; retain the lo-nybble
@hi     ora # .NULL_VALUE       ; add the new hi-nybble
        sta .frzn_page          ; update selected memory page
        jmp .bsod_BSOD_refresh  ; redraw the memory dump

@page_next:
        ; add 1 to hi-byte of memory page to display
        inc .frzn_page
        jmp .bsod_BSOD_refresh

@page_prev:
        ; subtract 1 from hi-byte of memory page to display
        dec .frzn_page
        jmp .bsod_BSOD_refresh

        ; F1: restore original screen:
        ;=======================================================================
@f1:    sei                     ; disable interrupts whilst we mess with memory
        lda # .MEM_ALL_RAM      ; disable I/O shield and ROM
        sta .zp+1               ;   to access data backup

        ; restore pages 4-7 & colour RAM:
        ;
        ; BSOD64 uses VIC bank 0 and $0400-$07FF for the screen, but the
        ; frozen program might have been using somewhere else. even if the
        ; program is not using $0400 for the screen, we still restore that
        ; area just in case it's using it for character RAM or bitmap screen!
        ;
        ldx # 0
-       lda .frzn_screen + $000, x
        sta .screen      + $000, x
        lda .frzn_screen + $100, x
        sta .screen      + $100, x
        lda .frzn_screen + $200, x
        sta .screen      + $200, x
        lda .frzn_screen + $300, x
        sta .screen      + $300, x

        ; colour RAM backup has to be read from RAM that could be under I/O
        ; and written with I/O on, so instead of oscilating I/O every byte
        ; we read four bytes ahead of time
        ;
        lda .frzn_color  + $300, x      ; (colour RAM backup $DB00-$DBFF)
        pha
        lda .frzn_color  + $200, x      ; (colour RAM backup $DA00-$DAFF)
        pha
        lda .frzn_color  + $100, x      ; (colour RAM backup $D900-$D9FF)
        pha
        lda .frzn_color  + $000, x      ; (colour RAM backup $D800-$D8FF)
        inc .zp+1                       ; enable I/O
        sta .vic_color   + $000, x
        pla
        sta .vic_color   + $100, x
        pla
        sta .vic_color   + $200, x
        pla
        sta .vic_color   + $300, x
        dec .zp+1                       ; disable I/O

        dex
        bne -
        
        ; restore VIC-II state:
        ;
        ; NOTE:
        ; - a write to $D012 & $D011 bit 7 sets the VIC-II interrupt raster
        ;   line, and $D01A bit 0 enables raster interrupts. BSOD64 has a
        ;   dummy interrupt handler, but for stability we disable raster
        ;   interrupts after setting the VIC-II state
        ;
        ldx # .VIC_COUNT+1              ; number of VIC-II registers
-       lda .frzn_vic-1, x              ; read register from the frozen state
        inc .zp+1                       ; enable I/O
        sta .vic-1,      x              ; write to hardware I/O
        dec .zp+1                       ; disable I/O
        dex
        bne -
        inc .zp+1                       ; enable I/O
        stx .vic+.VIC_IRQ_CONTROL       ; disable VIC-II interrupts (X=$00)

        ; restore VIC bank:
        lda .frzn_cia2
        sta .cia2+.CIA_PORTA

        ; set memory layout:
        lda # .MEM_DEFAULT
        sta .zp+1               ; restore KERNAL, BASIC & I/O
        cli                     ; re-enable interrupts

        ; PRESS ANY KEY
        ;
        ; note that because the standard KERNAL interrupts are running,
        ; `.kernal_scnkey` is being called to populate the buffer for us
        ;
-       jsr .kernal_getin       ; fetch a keypress -- returns in PETSCII!
        beq -                   ; if 0, no keypress, keep waiting
        jmp .bsod_BSOD


.str_top:
;-------------------------------------------------------------------------------
        !pet    .PET_WHITE, .PET_CLR, .PET_LCASE, .PET_CASEOFF
        !pet    .PET_RVSON, "PC:   A: X: Y: NV-BDIZC 0123456789ABCDEF"
        !pet    .PET_RVSOFF, "$"
        ; these values have to be stored within the code space because they
        ; have to be backed up early, before the I/O shield is turned off.
        ; if BSDO64 can run at all then, logically, these addresses are
        ; accessible
        !byte   .STR_HEXW
.frzn_pc:
.frzn_pc_lo:
        !byte   $00
.frzn_pc_hi:
        !byte   $00
        !pet    " "
        !byte   .STR_HEXB
.frzn_a:
        !byte   $00
        !pet    " "
        !byte   .STR_HEXB
.frzn_x:
        !byte   $00
        !pet    " "
        !byte   .STR_HEXB
.frzn_y:
        !byte   $00
        !pet    " "
        !byte   .STR_FLAGS
.frzn_f:
        !byte   %00000000
        !pet    " "

.str_banks:
        ;-----------------------------------------------------------------------
.str_banks_vic:
.str_banks_vic0:                ; VIC-bank 0 ($0000-$3FFF)
        !pet    "...."          ; zeropage, stack, work RAM
.str_banks_vic1:                ; VIC-bank 1 ($4000-$7FFF)
        !pet    "...."
.str_banks_vic2:                ; VIC-bank 2 ($8000-$BFFF)
        !pet    ".."            ; cart ROM LO ($8000-$9FFF)
.str_banks_b:
        !pet    ".."            ; BASIC ROM ($A000-$BFFF)
.str_banks_vic3:                ; VIC-bank 3 ($C000-$FFFF)
        !pet    "."             ; $C000 is always RAM
.str_banks_i:
        !pet    "."             ; I/O ($D000-$DFFF)
.str_banks_k:
        !pet    ".."            ; KERNAL ROM ($E000-$FFFF)
        !pet    .PET_RETURN

.str_stack:
;-------------------------------------------------------------------------------
        !pet    "SP:$"
        !byte   .STR_HEXB
.frzn_sp:
        !byte   $00
        !pet    " ", $5f
        !byte   .STR_END

.str_status:
;-------------------------------------------------------------------------------
        !byte   .STR_POS, 24, 0
        !pet    .PET_RVSON, .PET_WHITE
        !pet    .STR_REPT, 30, " "
        !pet    "F1:SCREEN"
        ; reposition the cursor to print "JSR"/"NMI"/"BRK"
        !byte   .STR_POS, 24, 0
        !byte   .STR_END
.str_jsr:
        ;-----------------------------------------------------------------------
        !pet    "JSR"
        !byte   .STR_END
.str_nmi:
        ;-----------------------------------------------------------------------
        !pet    "NMI"
        !byte   .STR_END
.str_brk:
        ;-----------------------------------------------------------------------
        !pet    "BRK:"
        !byte   .STR_HEXB
.frzn_brk:
        !byte   $00             ; the byte following the BRK instruction
        !byte   .STR_END


.str_mem:
;-------------------------------------------------------------------------------
        !byte   .STR_POS, 5, 0
        !pet    .PET_RVSON
        !pet    "$"
        !byte   .STR_HEXB
.frzn_page:
        !byte   $00
        !pet    "xx <CRSR>"
        !pet    .STR_REPT, 28, " "
        !pet    .PET_RVSOFF, .PET_LTBLUE
        !pet    "    -0-1-2-3-4-5-6-7-8-9-A-B-C-D-E-F"
        !pet    .PET_WHITE, .PET_RETURN
        !byte   .STR_END


.bsod_pop16:
;===============================================================================
        ldx # 16
        lda # .PET_CYAN
        bne +

@colour:lda # .PET_CYAN
+       jsr .kernal_chrout
        eor # (.PET_WHITE xor .PET_CYAN)
        sta @colour+1

        sei
        lda # .MEM_ALL_RAM      ; turn *off* BASIC,
        sta .zp+1               ;  KERNAL, and I/O
        lda (.zp_addr), y       ; read byte from frozen memory
        pha                     ; (put aside before printing)
        lda # .MEM_DEFAULT      ; turn *on* KERNAL,
        sta .zp+1               ;  BASIC, and I/O
        cli
        pla
        jsr .bsod_print_hex8

        iny                     ; move to next byte
        beq +
        dex
        bne @colour
+
--      rts

.bsod_print:
;===============================================================================
; in:   A       address of PETSCII string, lo-byte
;       X       address of PETSCII string, hi-byte
;-------------------------------------------------------------------------------
        sta .zp_str_lo          ; store the PETSCII string
        stx .zp_str_hi          ;  address in zero-page for indexing
        ldy # -1                ; string index (start at -1 for pre-increment)
        bne @loop               ; jump into the loop

        ;-----------------------------------------------------------------------
-       jsr @cc                 ; handle custom control code

@loop:  iny                     ; move to next character
        lda (.zp_str), y        ; read character from string
        beq --                  ; = .STR_END? -- stop printing
        cmp # $f0               ; values $F0-$FF are control codes
        bcs -                   ; handle custom control code?

        ; not a control code:
        jsr .kernal_chrout      ; print the character
        bne @loop               ; keep looping

        ; our custom control codes:
        ;
        ; .STR_POS : set cursor location
        ;-----------------------------------------------------------------------
@cc:    sbc # $f0               ; count control codes as $00..$0F
        tax                     ; =.STR_POS? -- set cursor position
        bne +

        iny                     ; (move to next byte in string)
        lda (.zp_str), y        ; read cursor row
        tax                     ; use X for KERNAL call
        iny                     ; (move to next byte in string)
        tya                     ; (backup Y before KERNAL call)
        pha                     ;
        lda (.zp_str), y        ; read cursor column
        tay                     ; move cursor col to Y-register
        clc                     ; = set cursor
        jsr .kernal_plot        ; call KERNAL to position cursor
        pla                     ; restore string index
        tay                     ;
        rts

        ; .STR_REPT : repeat a character
        ;-----------------------------------------------------------------------
+       dex                     ; =.STR_REPT? -- repeat a character
        bne +

        iny                     ; (move to next byte in string)
        lda (.zp_str), y        ; read repeat count
        tax                     ; use X for counter
        iny                     ; (move to next byte in string)
        lda (.zp_str), y        ; read character
-       jsr .kernal_chrout      ; print character
        dex
        bne -
        rts

        ; .STR_HEXW : print 16-bit hexadecimal value
        ;-----------------------------------------------------------------------
+       dex                     ; =.STR_HEXW? -- print 16-bit hexadecimal value
        bne +

        iny                     ; (move to next byte in string)
        lda (.zp_str), y        ; read value to print, hi-byte
        tax                     ; put aside hi-byte
        iny                     ; (move to next byte in string)
        lda (.zp_str), y        ; read value to print, lo-byte
        jmp .bsod_print_hex16

        ; .STR_HEXB : print 8-bit hexadecimal value
        ;-----------------------------------------------------------------------
+       dex                     ; =.STR_HEXB? -- print 8-bit hexadecimal value
        bne +

        iny                     ; (move to next byte in string)
        lda (.zp_str), y        ; read value to print
        jmp .bsod_print_hex8    ; print two hexadecimal digits

        ; .STR_FLAGS : print 8-bit binary value as flags
        ;-----------------------------------------------------------------------
+       dex                     ; =.STR_FLAGS?
        bne +

        iny                     ; (move to next byte in string)
        lda (.zp_str), y        ; read value to print
        sec
        jmp .bsod_print_bin8

        ;-----------------------------------------------------------------------
+       rts


bsod_hook:
;===============================================================================
; install hooks for BSOD64 to trap execution:
;
; when the KERNAL ROM is switched on, it controls the interrupt vectors at
; $FFFA-$FFFF. this means that there's some extra indirection that happens
; whenever an IRQ occurs. first, the KERNAL pushes A, X & Y onto the stack
; and then calls the vector at $0314; by default this is the routine that
; handles the BASIC interrupt, e.g. blinking the cursor. if the KERNAL is
; on but BASIC is off, the system will crash!
;-------------------------------------------------------------------------------
        sei                     ; disable interrupts whilst we alter them...

        lda # .MEM_ALL_RAM      ; turn *off* BASIC,
        sta .zp+1               ;  KERNAL, and I/O

        ; hook the NMI, i.e. the RESTORE key:
        ; -- invoke BSOD64 when RESTORE is pressed
        lda #< bsod_hook_nmi
        sta .vectors + .VECTOR_NMI+.lo
        sta .cpu_nmi_lo
        lda #> bsod_hook_nmi
        sta .vectors + .VECTOR_NMI+.hi
        sta .cpu_nmi_hi

        ; hook the IRQ when the KERNAL is off:
        ; -- do not crash the machine if the KERNAL is off, but interrupts
        ;    are on. this also has to check for the BRK bit, the KERNAL
        ;    does this instead when enabled
        lda #< bsod_hook_irq
        sta .cpu_irq_lo
        lda #> bsod_hook_irq
        sta .cpu_irq_hi

        ; hook the BRK vector when the KERNAL is on:
        ; -- when a BRK instruction is encountered, the KERNAL will detect
        ;    this and jump to its BRK vector instead of its IRQ vector;
        ;    this is why hooking the KERNAL IRQ vector isn't necessary
        lda #< bsod_hook_brk
        sta .vectors + .VECTOR_BRK+.lo
        lda #> bsod_hook_brk
        sta .vectors + .VECTOR_BRK+.hi

        lda # .MEM_DEFAULT      ; turn *on* KERNAL,
        sta .zp+1               ;  BASIC, and I/O

        cli                     ; re-enable interrupts
        rts

bsod_hook_nmi:
        ;=======================================================================
        pha                     ; for NMI, the KERNAL does *not* push 
        txa                     ;  the registers first, so we do that
        pha                     ;  ourselves to normalise against the
        tya                     ;  regular IRQ
        pha

        ; fallthrough
        ; ...

bsod_hook_brk:
        ;=======================================================================
        jsr bsod_irq            ; we won't ever be returning from here!

;;        pla
;;        tay
;;        pla
;;        tax
;;        pla
;;
;;        ; return from interrupt
;;        ; (restore processor flags, enable interrupts)
;;        rti

bsod_hook_irq:
        ;=======================================================================
        ; for BSOD64 integration we push the registers to the stack
        ;
        pha                     ; backup pre-interrupt A register
        txa                     ; backup pre-interrupt...
        pha                     ; ...X register
        tya                     ; backup pre-interrupt...
        pha                     ; ...Y register

        ; acknowledge interrupt to prevent double-firing:
        ; read from CIA1 to acknowledge interrupt
        bit .cia1 + .CIA_IRQ
        ; read-modify-write the VIC-II status register for raster IRQs
        asl .vic  + .VIC_IRQ_STATUS

        ;-----------------------------------------------------------------------
        ; check if BRK occurred:
        tsx                     ; we need to look on the stack
        lda .stack+4, x         ; retrieve the processor flags at interrupt
        and # %00010000         ; check the BRK bit
        beq .bsod_rti
        jsr bsod_irq            ; invoke BSOD64!

.bsod_rti:
        ;-----------------------------------------------------------------------
        ; pull the registers from the stack
        ; (in reverse order)
        pla                     ; pull...
        tay                     ; ...Y
        pla                     ; pull...
        tax                     ; ...X
        pla                     ; pull A

        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti


;===============================================================================
; interrupt handlers when BSOD64 is running:
;
; we don't want BSOD64 firing from within BSOD64! due to the freeze and reset
; the default KERNAL IRQs will be restored which are fine, but we do need to
; handle the IRQs for when the KERNAL ROM is off
;
; these routines do the minimum amount needed
; to service interrupts when the KERNAL ROM is off
;-------------------------------------------------------------------------------
.bsod_irq_nokernal:
        ;=======================================================================
        ; acknowledge the interrupt
        bit .cia1 + .CIA_IRQ

        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti

; likewise, without the KERNAL, the RAM underneath
; will determine the NMI handler (the RESTORE key)
;
.bsod_nmi_nokernal:
        ;=======================================================================
        ; acknowledge the interrupt
        bit .cia2 + .CIA_IRQ

        ; fallthrough
        ; ...

.bsod_nmi_kernalon:
        ;=======================================================================
        ; return from interrupt
        ; (restore processor flags, enable interrupts)
        rti


.bsod_push:
;===============================================================================
; normalise the stack to appear the same as the interrupt call would:
; this reduces the complexity of handling the different methods
; of invoking BSOD64
;
; this generates the following stack profile:
;
;       top  -> return-address, lo-byte (pushed by a JSR to `.bsod_freeze`)
;               return-address, hi-byte (pushed by a JSR to `.bsod_freeze`)
;               Y register              (pushed by this routine)
;               X register              (pushed by this routine)
;               A register              (pushed by this routine)
;               processor status        (pushed by this routine)
;               PC lo-byte              (pushed by the JSR to `.bsod_jsr`)
;               PC hi-byte              (pushed by the JSR to `.bsod_jsr`)
;
;-------------------------------------------------------------------------------
        ; push the processor status to the stack:
        ;
        ; even though an interrupt could occur between this instruction
        ; and the next, we need to capture the current interrupt flag state
        ; before changing it
        ;
        ; WARNING: the PHP instruction *always sets the BRK bit!*
        ; a flag is set (below) to indicate that BSOD64 was invoked by JSR
        ; instead of BRK to ensure that BSOD64 does not misinterpret the
        ; machine state -- BRK adds 2 to the program counter!
        ;
        php                     ; push processor flags
        sei                     ; disable interrupts
        ; push the registers
        pha                     ; A,
        txa                     ; X,
        pha
        tya                     ; Y
        pha
        ; set flag to indicate BSOD64 being invoked by JSR:
        ; this is important as the program-counter is off-by-one with JSR!
        sec                     ; set carry,
        ror .bsod_is_jsr        ;  and shift into bit 7 of flag

        rts                     ; return to begin the normal freezing process


.bsod_print_hex16:
;===============================================================================
; print a 16-bit value as PETSCII hexadecimal:
;
; in:   A       value, hi-byte
;       X       value, lo-byte
;-------------------------------------------------------------------------------
        jsr .bsod_print_hex8    ; print hi-byte first, X will be preserved
        txa                     ; switch to value's lo-byte

        ; fallthrough
        ; ...

.bsod_print_hex8:
;===============================================================================
; print a byte as PETSCII hexadecimal:
;
; in:   A       byte value
;
; out:  X, Y    (preserved)
;-------------------------------------------------------------------------------
        sed                     ; enable decimal mode
        pha                     ; put original value aside

        lsr                     ; shift upper nybble down
        lsr                     ; ...
        lsr                     ; ...
        lsr                     ; ...
        cmp # 9+1
        adc # $30               ; rebase to PETSCII '0' and above
        jsr .kernal_chrout      ; NOTE: no effect from decimal mode?

        pla                     ; retrieve original value
        and # %00001111         ; extract lower nybble
        cmp # 9+1
        adc # $30               ; rebase to PETSCII '0' and above

        cld                     ; disable decimal mode

        ; print the last digit
        ; (X & Y are preserved)
        jmp .kernal_chrout


.bsod_print_bin8:
;===============================================================================
; print a byte as PETSCII binary:
;
; in:   A       value
;      -c       use 0/1 digits
;      +c       use -/* digits
; out:  Y       (preserved)
;       X       (clobbered)
;
; TODO: compact into one copy of the loop
;-------------------------------------------------------------------------------
        ; check the carry state. if carry is set binary
        ; digits will be printed as "-" = 0 and "*" = 1
;;        bcs @sym                ; carry set = use symbols
;;
;;        ; print "0" & "1" digits
;;        ;---------------------------------------------------------------------
;;@dig:   asl                     ; pop a bit off the value
;;        tax                     ; remember remainder for next loop
;;        lda # $30               ; PETSCII '0'
;;        adc # 0                 ; PETSCII '1' if bit was 1
;;        jsr .kernal_chrout      ; print digit
;;
;;        txa                     ; retrieve remaining value before looping
;;        asl @count              ; shift counter along
;;        bne @dig                ; keep looping until the bit falls off
;;        
;;        rol @count              ; (put the bit back on the end)
;;        rts

        ; print "-" & "*" digits
        ;-----------------------------------------------------------------------
@sym:   asl                     ; pop a bit off the value
        tax                     ; remember remainder for next loop

        bcc +                   ; is bit 0 or 1?
        lda # $2a               ; PETSCII '*'
        +bit_skip2              ; `bit $....` (skip next 2-byte instruction)
+       lda # $2d               ; PETSCII '-'
        jsr .kernal_chrout

        txa                     ; retrieve remaining value before looping
        asl @count              ; shift counter along
        bne @sym                ; keep looping until the bit falls off

        rol @count              ; (put the bit back on the end)
        rts

@count  !byte   $00000001

;===============================================================================
; depending on how BSDO64 is invoked, different actions
; must be taken during the freeze and defrost
;
.bsod_is_jsr:   ; BSOD64 invoked by JSR? $00 = no, $80 (bit7) = yes
        !byte   $00
.bsod_is_brk:   ; BRK interrupt flag: $00 = no, $80 (bit7) = yes
        !byte   $00

; these values have to be stored within the code space because they have to be
; backed up early, before the I/O shield is turned if the BSDO64 code can run
; at all then, logically, these addresses are accessible
;
.frzn_cpu_ddir: ; backup of the CPU data-direction port ($00)
        !byte   .NULL_VALUE
                        
.frzn_cpu_port: ; backup of the CPU port ($01)
        !byte   .NULL_VALUE

.frzn_cia2:     ; CIA #2 port A (contains VIC bank)
        !byte   .NULL_VALUE

.ramtas_fix:    ; backup of the byte in RAM at $A000 due to RAMTAS bug!    
        !byte   $55
}